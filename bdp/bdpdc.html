<!DOCTYPE html><html lang="en"><head><title>bdp/bdpdc</title></head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"><meta name="groc-relative-root" content="../"><meta name="groc-document-path" content="bdp/bdpdc"><meta name="groc-project-path" content="js/src/bdp/bdpdc.js"><meta name="groc-github-url" content="https://github.com/aureooms/js-algo"><link rel="stylesheet" type="text/css" media="all" href="../assets/style.css"><script type="text/javascript" src="../assets/behavior.js"></script><body><div id="meta"><div class="file-path"><a href="https://github.com/aureooms/js-algo/blob/master/js/src/bdp/bdpdc.js">js/src/bdp/bdpdc.js</a></div></div><div id="document"><div class="segment"></div><div class="segment"><div class="comments "><div class="wrapper"><p>Bichromatic dominating pairs using the divide and conquer chainsaw.</p>
<p>see F. P. Preparata and M. I. Shamos, Computational Geometry, NY, 1985, p. 366.</p>
<p>Here the algorithm handles non-strict ( &gt;= ) dominance.</p>
<p>select( f, a, i, j, k ) where
  f is a comparator
  a the array of points
  [i, j[ the range to search in the array
  k the index to select</p>
<h2 id="select-partitions-the-array-in-tree-regions">select(...) partitions the array in tree regions</h2>
<h2 id="-lt-h--h--gt-h-">|    &lt;= h    | h |    &gt;= h    |</h2>
<p>i    ....    k  k+1   ....   j-1</p>
<p><strong>eq</strong>( d, v ) template for a function eq( a )
  returns true iff coordinate d of a equals v</p>
<p><strong>ne</strong>( d, v ) template for a function ne( y )
  returns true iff coordinate d of a is not equal to v</p>
<p>color( point )
  = 0 if point is blue
  = 1 if point is red</p>
<p>p = split( predicate, a, i, j )
  rearranges an array so that all elements for which predicate is false
  are in interval [i, p[ and all other elements are in interval [p, j[</p>
<p>swap( a, ai, aj, b, bi )
  swap elements from a in interval [ai, aj[ with elements from b in interval
  [bi, bi + aj - ai[</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">let</span> __bdpdc__ = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"> select, __eq__, __ne__, color, split, swap </span>) </span>{</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>a is an array of points</p>
<pre><code>note that we only consider points starting
at index i and ending at index j-1 in a</code></pre>
<p>points are arrays of coordinates</p>
<pre><code>d = dj - di is the number of coordinates of each point</code></pre>
<p><strong>f</strong> is a template for a function {coordinates^2} -&gt; {<0, =0, >0} named f</p>
<pre><code>i.e. for coordinates a and b

  f( a, b ) &lt; 0 means a &lt; b;
  f( a, b ) = 0 means a = b;
  f( a, b ) &gt; 0 means a &gt; b.</code></pre>
<p>out is the output array</p></div></div><div class="code"><div class="wrapper">	<span class="hljs-keyword">let</span> bdpdc = <span class="hljs-function"><span class="hljs-keyword">function</span>* (<span class="hljs-params"> __f__, a, i, j, di, dj </span>) </span>{

		<span class="hljs-keyword">let</span> k, h, x, y, p, q, m, n, _m, _n;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>empty or one element array case</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">if</span> ( i &gt;= j - <span class="hljs-number">1</span> ) <span class="hljs-keyword">return</span> ;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>base case : dj - di = d = 0
enumerate all red / blue pairs
[i, p[ contains only blue points
[p, j[ contains only red points
p = index of first red point</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">if</span> ( di === dj ) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>move all blue points left and all red points right
(arbitrary choice)</p></div></div><div class="code"><div class="wrapper">			p = split( color, a, i, j );</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>for each red point</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">for</span> ( x = p ; x &lt; j ; ++x ) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>for each blue point</p></div></div><div class="code"><div class="wrapper">				<span class="hljs-keyword">for</span> ( y = i ; y &lt; p ; ++y ) {

					<span class="hljs-keyword">yield</span> [ a[x], a[y] ] ;

				}
			}

		}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>recursion fairy</p>
<p>we compute m such that h is the median of
the ith coordinate of all points</p></div></div><div class="code"><div class="wrapper">		<span class="hljs-keyword">else</span> {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><hr>
<h2 id="-bampr-scrambled-">|                     b&amp;r scrambled                     |</h2>
<p>i                                                       j</p></div></div><div class="code"><div class="wrapper">			k = ( i + j ) / <span class="hljs-number">2</span> | <span class="hljs-number">0</span>;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><hr>
<h2 id="-bampr-scrambled-">|                     b&amp;r scrambled                     |</h2>
<p>i                         k                             j</p></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>select median element
O(n)</p></div></div><div class="code"><div class="wrapper">			select( __f__( di ), a, i, j, k );

			h = a[k][di];</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><hr>
<h2 id="-bampr-lt-h--h--bampr-gt-h-">|         b&amp;r &lt;= h        | h |         b&amp;r &gt;= h        |</h2>
<p>i                         k                             j</p></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>we do 3 recursive calls</p>
<p>first: for red and blue points with di &lt; h in R^d
we do not consider points with di = h because either</p>
<ol>
<li>red = h, blue &lt; h --&gt; handled by last call</li>
<li>red &lt; h, blue = h --&gt; red cannot dominate blue</li>
<li>red = h, blue = h --&gt; handled by last call
(would be &quot;red cannot dominate blue&quot; for strict dominance
in this 3rd case)</li>
</ol>
<p>second: for red and blue points with di &gt; h in R^d
we do not consider points with di = h for similar reasons as above</p>
<p>last: for red points with di &gt;= h and blue points with di &lt;= h in R^{d-1}
(would be &gt; and &lt; for strict dominance)</p>
<p>note that we do not need to handle the case where red &lt; h and blue &gt;= h
or red &lt;= h and blue &gt; h since red cannot dominate blue in those cases</p></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>first recursive call
we only consider points that have di &lt; h
since all points that have di = h will be handled later</p></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>move median elements from [ i, k [ in the [ x, k [ interval, x &gt;= i
O(n)</p></div></div><div class="code"><div class="wrapper">			x = split( __eq__( di, h ), a, i, k );</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><hr>
<h2 id="-bampr-lt-h--bampr--h--h--bampr-gt-h-">|    b&amp;r &lt; h    | b&amp;r = h | h |         b&amp;r &gt; h         |</h2>
<p>i               x         k                             j</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">yield</span>* bdpdc( __f__, a, i, x, di, dj );</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>move median elements from [ k + 1, j [ in the [ y, j [ interval, y &lt;= j
O(n)</p></div></div><div class="code"><div class="wrapper">			y = split( __ne__( di, h ), a, k + <span class="hljs-number">1</span>, j );</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><hr>
<h2 id="-bampr-lt-h--bampr--h--h--bampr--h--bampr-gt-h-">|    b&amp;r &lt; h    | b&amp;r = h | h | b&amp;r = h |    b&amp;r &gt; h    |</h2>
<p>i               x         k             y               j</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">yield</span>* bdpdc( __f__, a, y, j, di, dj );</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>since we do not touch median elements in the first two
recursive calls they are still at the correct place</p></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Now we want to</p>
<ul>
<li>move red points such that di &lt; h to the right</li>
<li>move red points such that di &gt;= h to the left</li>
</ul>
<p>/!\ Note that we also might think that we should</p>
<ul>
<li>move blue points such that di &gt; h to the right</li>
<li>move blue points such that di &lt;= h to the left
but after the selection algorithm this is already the case</li>
</ul></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><hr>
<h2 id="-bampr-lt-h--bampr--h--h--bampr--h--bampr-gt-h-">|    b&amp;r &lt; h    | b&amp;r = h | h | b&amp;r = h |    b&amp;r &gt; h    |</h2>
<p>i               x         k             y               j</p></div></div><div class="code"><div class="wrapper">			p = split( color, a, i, x );</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><hr>
<h2 id="-b-lt-h--r-lt-h--bampr--h--h--bampr--h--bampr-gt-h-">| b &lt; h | r &lt; h | b&amp;r = h | h | b&amp;r = h |    b&amp;r &gt; h    |</h2>
<p>i       p       x         k             y               j</p></div></div><div class="code"><div class="wrapper">			q = split( color, a, y, j );</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><hr>
<h2 id="-b-lt-h--r-lt-h--bampr--h--h--bampr--h--b-gt-h--r-gt-h-">| b &lt; h | r &lt; h | b&amp;r = h | h | b&amp;r = h | b &gt; h | r &gt; h |</h2>
<p>i       p       x         k             y       q       j</p></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>we now want to swap r &lt; h elements with r &gt; h elements
we have 3 cases</p>
<ol>
<li>x - p = j - q</li>
<li>x - p &lt; j - q</li>
<li>x - p &gt; j - q</li>
</ol></div></div><div class="code"><div class="wrapper">			m = x - p;
			n = j - q;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><ol>
<li>x - p = j - q</li>
</ol></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">if</span> ( m === n ) {
				swap( a, q, j, a, p );</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><hr>
<h2 id="-b-lt-h--r-gt-h--bampr--h--h--bampr--h--b-gt-h--r-lt-h-">| b &lt; h | r &gt; h | b&amp;r = h | h | b&amp;r = h | b &gt; h | r &lt; h |</h2>
<p>i       p       x         k             y       q       j</p></div></div><div class="code"><div class="wrapper">				j = y;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><hr>
<h2 id="-b-lt-h--r-gt-h--bampr--h--h--bampr--h--b-gt-h--r-lt-h-">| b &lt; h | r &gt; h | b&amp;r = h | h | b&amp;r = h | b &gt; h | r &lt; h |</h2>
<p>i       p       x         k             j      ...</p></div></div><div class="code"><div class="wrapper">			}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><ol>
<li>x - p &lt; j - q</li>
</ol></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( m &lt; n ) {

				swap( a, p, x, a, q );</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><hr>
<h2 id="-b-lt-h--r-gt-h--bampr--h--h--bampr--h--b-gt-h--r-lt-h--r-gt-h-">| b &lt; h | r &gt; h | b&amp;r = h | h | b&amp;r = h | b &gt; h | r &lt; h | r &gt; h |</h2>
<p>i       p       x         k             y       q      q+m      j</p></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>we now want to swap b &gt; h and r &lt; h elements with r &gt; h elements
                    [y,q[    [q,q+m[             [q+m,j[
we have 2 cases</p>
<ol>
<li>(q + m) - y &gt;= j - (q + m) [OR  &gt;]</li>
<li>(q + m) - y  &lt; j - (q + m) [OR &lt;=]</li>
</ol></div></div><div class="code"><div class="wrapper">				_m = (q + m) - y;
				_n = j - (q + m);</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><ol>
<li>(q + m) - y &gt;= j - (q + m)</li>
</ol></div></div><div class="code"><div class="wrapper">				<span class="hljs-keyword">if</span> ( _m &gt;= _n ) {
					swap( a, q + m, j, a, y );
				}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><ol>
<li>(q + m) - y  &lt; j - (q + m)</li>
</ol></div></div><div class="code"><div class="wrapper">				<span class="hljs-keyword">else</span> {
					swap( a, j - _m, j, a, y );
				}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><hr>
<h2 id="-b-lt-h--r-gt-h--bampr--h--h--bampr--h--r-gt-h--bgth-amp-rlth-">| b &lt; h | r &gt; h | b&amp;r = h | h | b&amp;r = h | r &gt; h |   b&gt;h &amp; r&lt;h   |</h2>
<p>i       p       x         k             y      y+_n             j</p></div></div><div class="code"><div class="wrapper">				j = y + _n;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><hr>
<h2 id="-b-lt-h--r-gt-h--bampr--h--h--bampr--h--r-gt-h--bgth-amp-rlth-">| b &lt; h | r &gt; h | b&amp;r = h | h | b&amp;r = h | r &gt; h |   b&gt;h &amp; r&lt;h   |</h2>
<p>i       p       x         k             y       j      ...</p></div></div><div class="code"><div class="wrapper">			}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><ol>
<li>x - p &gt; j - q</li>
</ol></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">else</span> {

				swap( a, q, j, a, p );</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><hr>
<h2 id="-b-lt-h--r-gt-h--r-lt-h--bampr--h--h--bampr--h--b-gt-h--r-lt-h-">| b &lt; h | r &gt; h | r &lt; h | b&amp;r = h | h | b&amp;r = h | b &gt; h | r &lt; h |</h2>
<p>i       p      p+n      x         k             y       q       j</p></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>we now want to swap r &lt; h with b&amp;r = h elements
we have 2 cases</p>
<ol>
<li>x - (p + n) &gt;= y - x</li>
<li>x - (p + n)  &lt; y - x</li>
</ol></div></div><div class="code"><div class="wrapper">				_m = x - (p + n);
				_n = y - x;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><ol>
<li>x - (p + n) &gt;= y - x</li>
</ol></div></div><div class="code"><div class="wrapper">				<span class="hljs-keyword">if</span> ( _m &gt;= _n ) {
					swap( a, x, y, a, p + n );
				}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><ol>
<li>x - (p + n)  &lt; y - x</li>
</ol></div></div><div class="code"><div class="wrapper">				<span class="hljs-keyword">else</span> {
					swap( a, y - _m, y, a, p + n );
				}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><hr>
<h2 id="-b-lt-h--r-gt-h--bampr--h--h--bampr--h--bgth-amp-rlth-">| b &lt; h | r &gt; h |     b&amp;r = h     | h | b&amp;r = h | b&gt;h &amp; r&lt;h |</h2>
<p>i       p      p+n                k            y-_m         j</p></div></div><div class="code"><div class="wrapper">				j = y - _m;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><hr>
<h2 id="-b-lt-h--r-gt-h--bampr--h--h--bampr--h--bgth-amp-rlth-">| b &lt; h | r &gt; h |     b&amp;r = h     | h | b&amp;r = h | b&gt;h &amp; r&lt;h |</h2>
<p>i       p      p+n                k             j    ...</p></div></div><div class="code"><div class="wrapper">			}</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>[i, j[ now contains only b &lt;= h and r &gt;= h points
in this new interval, all r points dominate b points
for the ith coordinate
we can thus ask the recursion fairy to take care of the other
dj - di - 1 dimensions left</p></div></div><div class="code"><div class="wrapper">			<span class="hljs-keyword">yield</span>* bdpdc( __f__, a, i, j, di + <span class="hljs-number">1</span>, dj );

		}

	};

	<span class="hljs-keyword">return</span> bdpdc;

};

exports.__bdpdc__ = __bdpdc__;</div></div></div></div></body></html>